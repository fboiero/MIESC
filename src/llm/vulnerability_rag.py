"""
Vulnerability RAG (Retrieval-Augmented Generation) for MIESC
=============================================================

RAG system that enhances vulnerability analysis with contextual
information from a knowledge base of known vulnerabilities.

Based on SmartLLM (2024) - using RAG for improved detection accuracy.

Features:
- Embedding-based similarity search
- SWC Registry integration
- Real-world exploit examples
- Contextual analysis enhancement

Author: Fernando Boiero <fboiero@frvm.utn.edu.ar>
Institution: UNDEF - IUA
Date: January 2026
"""

import json
import logging
import hashlib
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Tuple
from pathlib import Path

logger = logging.getLogger(__name__)


@dataclass
class VulnerabilityExample:
    """A known vulnerability example for RAG context."""
    id: str
    swc_id: Optional[str]
    cwe_id: Optional[str]
    title: str
    description: str
    vulnerable_code: str
    fixed_code: Optional[str]
    attack_scenario: Optional[str]
    severity: str
    category: str
    real_exploit: Optional[str] = None
    tags: List[str] = field(default_factory=list)
    embedding: Optional[List[float]] = None


@dataclass
class SimilarVuln:
    """A similar vulnerability from the knowledge base."""
    example: VulnerabilityExample
    similarity_score: float
    relevance_reason: str


@dataclass
class EnhancedFinding:
    """A finding enhanced with RAG context."""
    original_finding: Dict[str, Any]
    similar_vulns: List[SimilarVuln]
    enhanced_description: str
    exploit_scenario: Optional[str]
    remediation_code: Optional[str]
    confidence_adjustment: float
    additional_references: List[str]


# =============================================================================
# SWC REGISTRY - Smart Contract Weakness Classification
# =============================================================================

SWC_REGISTRY: Dict[str, VulnerabilityExample] = {
    "SWC-107": VulnerabilityExample(
        id="SWC-107",
        swc_id="SWC-107",
        cwe_id="CWE-841",
        title="Reentrancy",
        description=(
            "One of the major dangers of calling external contracts is that they can "
            "take over the control flow. In the reentrancy attack, a malicious contract "
            "calls back into the calling contract before the first invocation of the "
            "function is finished."
        ),
        vulnerable_code="""
function withdraw(uint256 _amount) public {
    require(balances[msg.sender] >= _amount);
    (bool success,) = msg.sender.call{value: _amount}("");
    require(success);
    balances[msg.sender] -= _amount;  // State update AFTER external call
}
""",
        fixed_code="""
function withdraw(uint256 _amount) public nonReentrant {
    require(balances[msg.sender] >= _amount);
    balances[msg.sender] -= _amount;  // State update BEFORE external call
    (bool success,) = msg.sender.call{value: _amount}("");
    require(success);
}
""",
        attack_scenario=(
            "Attacker deploys contract with fallback that calls withdraw() again. "
            "First call: balance check passes, ETH sent, fallback triggers. "
            "Second call: balance still not updated, check passes again. "
            "Repeat until contract drained."
        ),
        severity="high",
        category="reentrancy",
        real_exploit="The DAO Hack ($60M, 2016)",
        tags=["reentrancy", "external-call", "state-update"],
    ),

    "SWC-105": VulnerabilityExample(
        id="SWC-105",
        swc_id="SWC-105",
        cwe_id="CWE-284",
        title="Unprotected Ether Withdrawal",
        description=(
            "Due to missing or insufficient access controls, malicious parties can "
            "withdraw some or all Ether from the contract account."
        ),
        vulnerable_code="""
function withdrawAll() public {
    // No access control!
    payable(msg.sender).transfer(address(this).balance);
}
""",
        fixed_code="""
function withdrawAll() public onlyOwner {
    payable(msg.sender).transfer(address(this).balance);
}
""",
        attack_scenario=(
            "Anyone can call withdrawAll() and drain all ETH from the contract. "
            "No authentication or authorization check is performed."
        ),
        severity="critical",
        category="access-control",
        real_exploit="Parity Multisig Hack ($150M frozen, 2017)",
        tags=["access-control", "withdrawal", "authorization"],
    ),

    "SWC-106": VulnerabilityExample(
        id="SWC-106",
        swc_id="SWC-106",
        cwe_id="CWE-284",
        title="Unprotected SELFDESTRUCT Instruction",
        description=(
            "A contract without access control on selfdestruct can be destroyed by "
            "anyone, permanently losing all funds and functionality."
        ),
        vulnerable_code="""
function kill() public {
    selfdestruct(payable(msg.sender));
}
""",
        fixed_code="""
function kill() public onlyOwner {
    selfdestruct(payable(owner));
}
""",
        attack_scenario=(
            "Attacker calls kill() function. Contract is destroyed. "
            "All funds are sent to attacker. Contract code is erased from blockchain."
        ),
        severity="critical",
        category="access-control",
        real_exploit="Parity Kill Bug ($150M frozen, 2017)",
        tags=["selfdestruct", "access-control", "permanent-loss"],
    ),

    "SWC-104": VulnerabilityExample(
        id="SWC-104",
        swc_id="SWC-104",
        cwe_id="CWE-252",
        title="Unchecked Call Return Value",
        description=(
            "The return value of a message call is not checked. Execution will resume "
            "even if the called contract throws an exception."
        ),
        vulnerable_code="""
function sendEther(address payable _to, uint256 _amount) public {
    _to.call{value: _amount}("");  // Return value not checked!
    // Continues even if call fails
}
""",
        fixed_code="""
function sendEther(address payable _to, uint256 _amount) public {
    (bool success,) = _to.call{value: _amount}("");
    require(success, "Transfer failed");
}
""",
        attack_scenario=(
            "External call fails silently. Contract state may become inconsistent. "
            "User thinks operation succeeded but it didn't."
        ),
        severity="medium",
        category="unchecked-call",
        tags=["unchecked-return", "low-level-call", "error-handling"],
    ),

    "SWC-115": VulnerabilityExample(
        id="SWC-115",
        swc_id="SWC-115",
        cwe_id="CWE-477",
        title="Authorization through tx.origin",
        description=(
            "tx.origin is a global variable in Solidity which returns the address of "
            "the account that sent the transaction. Using tx.origin for authorization "
            "could make a contract vulnerable if an authorized account calls a malicious contract."
        ),
        vulnerable_code="""
function transferTo(address payable dest, uint amount) public {
    require(tx.origin == owner);  // BAD: uses tx.origin
    dest.transfer(amount);
}
""",
        fixed_code="""
function transferTo(address payable dest, uint amount) public {
    require(msg.sender == owner);  // GOOD: uses msg.sender
    dest.transfer(amount);
}
""",
        attack_scenario=(
            "Attacker creates malicious contract with legitimate-looking function. "
            "Owner interacts with it. Malicious contract calls transferTo(). "
            "tx.origin is still owner, authorization passes, funds stolen."
        ),
        severity="high",
        category="access-control",
        tags=["tx-origin", "phishing", "authorization"],
    ),

    "SWC-116": VulnerabilityExample(
        id="SWC-116",
        swc_id="SWC-116",
        cwe_id="CWE-829",
        title="Block values as a proxy for time",
        description=(
            "Contracts often need access to time values to perform certain types of "
            "functionality. Values such as block.timestamp and block.number can be "
            "manipulated by miners to some degree."
        ),
        vulnerable_code="""
function play() public payable {
    require(msg.value >= 1 ether);
    if (block.timestamp % 15 == 0) {  // Miner can manipulate
        payable(msg.sender).transfer(address(this).balance);
    }
}
""",
        fixed_code="""
// Use Chainlink VRF for randomness instead
function play() public payable {
    require(msg.value >= 1 ether);
    requestRandomness();  // Use verifiable random function
}
""",
        attack_scenario=(
            "Miner submits transaction with manipulated timestamp. "
            "Wins lottery by ensuring condition is met. "
            "Block.timestamp can be adjusted by ~15 seconds."
        ),
        severity="medium",
        category="randomness",
        tags=["timestamp", "block-values", "randomness", "miner-manipulation"],
    ),

    "SWC-101": VulnerabilityExample(
        id="SWC-101",
        swc_id="SWC-101",
        cwe_id="CWE-190",
        title="Integer Overflow and Underflow",
        description=(
            "An overflow/underflow happens when an arithmetic operation reaches the "
            "maximum or minimum size of a type. For instance if a number is stored "
            "in the uint8 type, it means that the number is stored in a 8 bits unsigned "
            "number ranging from 0 to 2^8-1."
        ),
        vulnerable_code="""
// Solidity < 0.8.0
function transfer(address _to, uint256 _amount) public {
    require(balances[msg.sender] >= _amount);
    balances[msg.sender] -= _amount;  // Can underflow!
    balances[_to] += _amount;  // Can overflow!
}
""",
        fixed_code="""
// Solidity 0.8.0+: Built-in overflow checks
// Or use SafeMath for older versions
using SafeMath for uint256;

function transfer(address _to, uint256 _amount) public {
    require(balances[msg.sender] >= _amount);
    balances[msg.sender] = balances[msg.sender].sub(_amount);
    balances[_to] = balances[_to].add(_amount);
}
""",
        attack_scenario=(
            "Attacker transfers more than they have, causing underflow. "
            "Balance wraps around to max uint256. "
            "Attacker now has ~2^256 tokens."
        ),
        severity="high",
        category="arithmetic",
        real_exploit="BEC Token ($900M theoretically, 2018)",
        tags=["overflow", "underflow", "arithmetic", "safemath"],
    ),

    "SWC-112": VulnerabilityExample(
        id="SWC-112",
        swc_id="SWC-112",
        cwe_id="CWE-829",
        title="Delegatecall to Untrusted Callee",
        description=(
            "Delegatecall is a special variant of message call that allows the callee "
            "to modify the caller's state. If the target of a delegatecall is controlled "
            "by an attacker, they can execute arbitrary code in the context of the calling contract."
        ),
        vulnerable_code="""
function execute(address _target, bytes memory _data) public {
    // Arbitrary delegatecall!
    _target.delegatecall(_data);
}
""",
        fixed_code="""
mapping(address => bool) public allowedTargets;

function execute(address _target, bytes memory _data) public onlyOwner {
    require(allowedTargets[_target], "Target not allowed");
    _target.delegatecall(_data);
}
""",
        attack_scenario=(
            "Attacker provides malicious contract as target. "
            "Delegatecall executes attacker's code with victim's storage. "
            "Attacker can modify any state variable, including owner."
        ),
        severity="critical",
        category="delegatecall",
        real_exploit="Parity Wallet ($30M, 2017)",
        tags=["delegatecall", "proxy", "code-injection"],
    ),

    "SWC-133": VulnerabilityExample(
        id="SWC-133",
        swc_id="SWC-133",
        cwe_id="CWE-829",
        title="Hash Collisions With Multiple Variable Length Arguments",
        description=(
            "Using abi.encodePacked() with multiple variable length arguments can lead to "
            "hash collisions. This is because abi.encodePacked concatenates the arguments "
            "directly without length prefixes."
        ),
        vulnerable_code="""
function collideHash(string memory a, string memory b) public pure returns (bytes32) {
    // "ab" + "c" produces same hash as "a" + "bc"
    return keccak256(abi.encodePacked(a, b));
}
""",
        fixed_code="""
function safeHash(string memory a, string memory b) public pure returns (bytes32) {
    // Use abi.encode which adds length prefixes
    return keccak256(abi.encode(a, b));
}
""",
        attack_scenario=(
            "Attacker finds inputs that produce hash collision. "
            "Bypasses signature verification or access control. "
            "Example: ('a', 'bc') and ('ab', 'c') produce same hash."
        ),
        severity="medium",
        category="hash-collision",
        tags=["encodepacked", "hash", "collision", "signature"],
    ),
}


# Additional examples from real exploits
EXPLOIT_EXAMPLES: Dict[str, VulnerabilityExample] = {
    "dao-hack": VulnerabilityExample(
        id="dao-hack",
        swc_id="SWC-107",
        cwe_id="CWE-841",
        title="The DAO Reentrancy Attack",
        description=(
            "The attacker exploited the splitDAO function which called the recipient's "
            "fallback function before updating state. By repeatedly calling splitDAO "
            "from the fallback, they drained ~$60M in ETH."
        ),
        vulnerable_code="""
function splitDAO(uint _proposalID, address _newCurator) returns (bool) {
    ...
    // Transfer happens before state update
    rewardToken[msg.sender] += reward;
    if (!p.creator.send(p.amount)) throw;
    balances[msg.sender] = 0;  // Too late!
    ...
}
""",
        fixed_code="""
function splitDAO(uint _proposalID, address _newCurator) nonReentrant returns (bool) {
    ...
    // Update state first
    uint balanceToTransfer = balances[msg.sender];
    balances[msg.sender] = 0;
    rewardToken[msg.sender] += reward;
    if (!p.creator.send(p.amount)) throw;
    ...
}
""",
        attack_scenario=(
            "1. Attacker creates malicious contract\n"
            "2. Calls splitDAO with malicious contract as recipient\n"
            "3. splitDAO sends ETH, triggers fallback\n"
            "4. Fallback calls splitDAO again\n"
            "5. Balance not yet updated, passes check\n"
            "6. Repeat until drained"
        ),
        severity="critical",
        category="reentrancy",
        real_exploit="The DAO ($60M, June 2016)",
        tags=["reentrancy", "historic", "ethereum-fork"],
    ),

    "beanstalk-governance": VulnerabilityExample(
        id="beanstalk-governance",
        swc_id=None,
        cwe_id="CWE-284",
        title="Beanstalk Governance Flash Loan Attack",
        description=(
            "Attacker used flash loan to borrow governance tokens, immediately "
            "passed a malicious proposal, and drained the protocol's funds."
        ),
        vulnerable_code="""
function propose(address[] memory targets, bytes[] memory calldatas) public {
    require(getVotes(msg.sender) >= proposalThreshold());
    // No time delay or snapshot before proposal
    ...
}
""",
        fixed_code="""
function propose(address[] memory targets, bytes[] memory calldatas) public {
    // Snapshot votes BEFORE proposal
    uint256 proposerVotes = getPastVotes(msg.sender, block.number - 1);
    require(proposerVotes >= proposalThreshold());
    // Timelock execution
    ...
}
""",
        attack_scenario=(
            "1. Flash loan $1B in governance tokens\n"
            "2. Propose malicious governance action\n"
            "3. Vote with borrowed tokens (>67% voting power)\n"
            "4. Execute proposal immediately\n"
            "5. Drain treasury ($182M)\n"
            "6. Repay flash loan"
        ),
        severity="critical",
        category="governance",
        real_exploit="Beanstalk ($182M, April 2022)",
        tags=["governance", "flash-loan", "defi"],
    ),

    "wormhole-bridge": VulnerabilityExample(
        id="wormhole-bridge",
        swc_id=None,
        cwe_id="CWE-347",
        title="Wormhole Bridge Signature Verification Bypass",
        description=(
            "Attacker exploited a vulnerability in the signature verification "
            "to mint 120,000 wETH without backing."
        ),
        vulnerable_code="""
function complete_transfer(bytes memory vaa) public {
    // Insufficient signature verification
    (IWormhole.Signature[] memory signatures, bytes memory body) = parseVAA(vaa);
    require(signatures.length >= guardian_set.num_guardians / 3);
    // Attacker bypassed this check
    ...
}
""",
        fixed_code="""
function complete_transfer(bytes memory vaa) public {
    // Proper signature verification
    require(verifyVM(vaa).valid, "Invalid VAA");
    require(!processedVAAs[vaa.hash], "Already processed");
    processedVAAs[vaa.hash] = true;
    ...
}
""",
        attack_scenario=(
            "1. Attacker found bug in signature verification\n"
            "2. Crafted fake VAA (Verified Action Approval)\n"
            "3. Bridge accepted forged message\n"
            "4. Minted 120,000 wETH ($326M) on Solana\n"
            "5. Bridged some to Ethereum and sold"
        ),
        severity="critical",
        category="bridge",
        real_exploit="Wormhole ($326M, February 2022)",
        tags=["bridge", "signature", "cross-chain"],
    ),
}


class VulnerabilityRAG:
    """
    Retrieval-Augmented Generation for vulnerability analysis.

    Uses a knowledge base of known vulnerabilities to enhance
    detection and provide contextual information.
    """

    def __init__(
        self,
        ollama_base_url: str = "http://localhost:11434",
        model: str = "deepseek-coder:6.7b",
        top_k: int = 3,
    ):
        """
        Initialize the RAG system.

        Args:
            ollama_base_url: Ollama API URL
            model: Model for analysis
            top_k: Number of similar vulns to retrieve
        """
        self.base_url = ollama_base_url
        self.model = model
        self.top_k = top_k

        # Combine all knowledge bases
        self.knowledge_base: Dict[str, VulnerabilityExample] = {}
        self.knowledge_base.update(SWC_REGISTRY)
        self.knowledge_base.update(EXPLOIT_EXAMPLES)

        # Build tag index for fast lookup
        self._tag_index: Dict[str, List[str]] = {}
        self._build_tag_index()

        logger.info(f"VulnerabilityRAG initialized with {len(self.knowledge_base)} examples")

    def _build_tag_index(self) -> None:
        """Build inverted index from tags to example IDs."""
        for example_id, example in self.knowledge_base.items():
            for tag in example.tags:
                tag_lower = tag.lower()
                if tag_lower not in self._tag_index:
                    self._tag_index[tag_lower] = []
                self._tag_index[tag_lower].append(example_id)

            # Also index by category
            if example.category:
                cat_lower = example.category.lower()
                if cat_lower not in self._tag_index:
                    self._tag_index[cat_lower] = []
                self._tag_index[cat_lower].append(example_id)

    def search_similar(
        self,
        finding: Dict[str, Any],
        code_context: str = "",
    ) -> List[SimilarVuln]:
        """
        Find similar vulnerabilities in the knowledge base.

        Args:
            finding: The vulnerability finding to search for
            code_context: Code context for better matching

        Returns:
            List of similar vulnerabilities
        """
        vuln_type = finding.get("type", "").lower()
        description = finding.get("description", "").lower()

        candidates = set()
        scores: Dict[str, float] = {}

        # Search by type/category
        if vuln_type in self._tag_index:
            for example_id in self._tag_index[vuln_type]:
                candidates.add(example_id)
                scores[example_id] = scores.get(example_id, 0) + 0.5

        # Search by keywords in description
        keywords = self._extract_keywords(description)
        for keyword in keywords:
            if keyword in self._tag_index:
                for example_id in self._tag_index[keyword]:
                    candidates.add(example_id)
                    scores[example_id] = scores.get(example_id, 0) + 0.3

        # Search by SWC ID if present
        swc_id = finding.get("swc_id") or finding.get("swc")
        if swc_id:
            swc_upper = swc_id.upper()
            if swc_upper in self.knowledge_base:
                candidates.add(swc_upper)
                scores[swc_upper] = scores.get(swc_upper, 0) + 0.8

        # Score candidates and get top-k
        results = []
        for example_id in candidates:
            example = self.knowledge_base.get(example_id)
            if not example:
                continue

            score = scores.get(example_id, 0)

            # Boost for code similarity
            if code_context and example.vulnerable_code:
                code_sim = self._code_similarity(code_context, example.vulnerable_code)
                score += code_sim * 0.4

            # Normalize score
            score = min(1.0, score)

            results.append(SimilarVuln(
                example=example,
                similarity_score=score,
                relevance_reason=self._get_relevance_reason(finding, example),
            ))

        # Sort by score and return top-k
        results.sort(key=lambda x: -x.similarity_score)
        return results[:self.top_k]

    async def analyze_with_context(
        self,
        finding: Dict[str, Any],
        code: str,
    ) -> EnhancedFinding:
        """
        Enhance a finding with RAG context.

        Args:
            finding: The vulnerability finding
            code: Contract source code

        Returns:
            Enhanced finding with context
        """
        # Find similar vulnerabilities
        similar = self.search_similar(finding, code)

        # Build context for LLM
        context_parts = []
        for sim in similar:
            context_parts.append(
                f"**Similar Vulnerability: {sim.example.title}**\n"
                f"- Description: {sim.example.description[:200]}...\n"
                f"- Real Exploit: {sim.example.real_exploit or 'N/A'}\n"
                f"- Relevance: {sim.relevance_reason}"
            )

        context = "\n\n".join(context_parts) if context_parts else "No similar vulnerabilities found."

        # Query LLM for enhanced analysis
        enhanced = await self._enhance_with_llm(finding, code, context)

        # Build references
        references = []
        for sim in similar:
            if sim.example.swc_id:
                references.append(f"https://swcregistry.io/docs/{sim.example.swc_id}")
            if sim.example.real_exploit:
                references.append(sim.example.real_exploit)

        # Calculate confidence adjustment
        confidence_adjustment = 0.0
        if similar:
            # Boost confidence if similar known vulnerabilities exist
            confidence_adjustment = min(0.2, similar[0].similarity_score * 0.25)

        return EnhancedFinding(
            original_finding=finding,
            similar_vulns=similar,
            enhanced_description=enhanced.get("description", finding.get("description", "")),
            exploit_scenario=enhanced.get("exploit_scenario"),
            remediation_code=enhanced.get("remediation_code"),
            confidence_adjustment=confidence_adjustment,
            additional_references=references,
        )

    async def _enhance_with_llm(
        self,
        finding: Dict[str, Any],
        code: str,
        context: str,
    ) -> Dict[str, Any]:
        """Use LLM to enhance finding with RAG context."""
        import aiohttp

        prompt = f"""Based on similar known vulnerabilities, enhance this security finding:

## Original Finding
- Type: {finding.get('type', 'unknown')}
- Severity: {finding.get('severity', 'unknown')}
- Description: {finding.get('description', '')}

## Similar Known Vulnerabilities
{context}

## Code Context
```solidity
{code[:2000]}
```

Provide:
1. Enhanced description with more technical detail
2. Specific exploit scenario for this contract
3. Remediation code example

Respond in JSON:
{{
    "description": "Enhanced description",
    "exploit_scenario": "Step-by-step exploit",
    "remediation_code": "Fixed code example"
}}
"""

        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(
                    f"{self.base_url}/api/chat",
                    json={
                        "model": self.model,
                        "messages": [
                            {"role": "system", "content": "You are an expert smart contract security auditor."},
                            {"role": "user", "content": prompt}
                        ],
                        "stream": False,
                        "options": {"temperature": 0.1},
                    },
                    timeout=aiohttp.ClientTimeout(total=60),
                ) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        content = data.get("message", {}).get("content", "")
                        return self._parse_json(content)
        except Exception as e:
            logger.warning(f"LLM enhancement failed: {e}")

        return {}

    def _extract_keywords(self, text: str) -> List[str]:
        """Extract relevant keywords from text."""
        # Common vulnerability-related keywords
        relevant_keywords = [
            "reentrancy", "reentrant", "overflow", "underflow", "arithmetic",
            "access", "control", "owner", "admin", "delegatecall", "proxy",
            "selfdestruct", "suicide", "timestamp", "block", "random",
            "oracle", "price", "flash", "loan", "front-running", "sandwich",
            "signature", "ecrecover", "hash", "collision", "transfer",
            "call", "send", "withdraw", "deposit", "balance", "token",
            "erc20", "erc721", "approval", "allowance", "governance", "vote",
        ]

        found = []
        text_lower = text.lower()
        for keyword in relevant_keywords:
            if keyword in text_lower:
                found.append(keyword)

        return found[:5]  # Limit to top 5

    def _code_similarity(self, code1: str, code2: str) -> float:
        """Calculate simple code similarity."""
        # Extract function calls and keywords
        import re

        def extract_tokens(code: str) -> set:
            # Extract function calls
            calls = set(re.findall(r'\b(\w+)\s*\(', code.lower()))
            # Extract keywords
            keywords = set(re.findall(r'\b(require|if|revert|transfer|send|call|delegatecall)\b', code.lower()))
            return calls.union(keywords)

        tokens1 = extract_tokens(code1)
        tokens2 = extract_tokens(code2)

        if not tokens1 or not tokens2:
            return 0.0

        intersection = tokens1.intersection(tokens2)
        union = tokens1.union(tokens2)

        return len(intersection) / len(union) if union else 0.0

    def _get_relevance_reason(
        self,
        finding: Dict[str, Any],
        example: VulnerabilityExample,
    ) -> str:
        """Explain why an example is relevant."""
        reasons = []

        vuln_type = finding.get("type", "").lower()
        if example.category and vuln_type in example.category.lower():
            reasons.append(f"Same vulnerability category ({example.category})")

        if example.real_exploit:
            reasons.append(f"Known real-world exploit: {example.real_exploit}")

        if example.swc_id:
            reasons.append(f"SWC Registry: {example.swc_id}")

        return "; ".join(reasons) if reasons else "Pattern similarity"

    def _parse_json(self, content: str) -> Dict[str, Any]:
        """Parse JSON from response."""
        try:
            start = content.find('{')
            end = content.rfind('}') + 1
            if start >= 0 and end > start:
                return json.loads(content[start:end])
        except json.JSONDecodeError:
            pass
        return {}

    def get_swc_info(self, swc_id: str) -> Optional[VulnerabilityExample]:
        """Get SWC Registry information by ID."""
        return self.knowledge_base.get(swc_id.upper())

    def get_all_categories(self) -> List[str]:
        """Get all vulnerability categories in the knowledge base."""
        categories = set()
        for example in self.knowledge_base.values():
            if example.category:
                categories.add(example.category)
        return sorted(categories)


# Export
__all__ = [
    "VulnerabilityRAG",
    "VulnerabilityExample",
    "SimilarVuln",
    "EnhancedFinding",
    "SWC_REGISTRY",
    "EXPLOIT_EXAMPLES",
]
