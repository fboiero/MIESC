"""
Tests for VulnerabilityRAG module.

Sprint 1.1: Comprehensive tests for the RAG system covering:
- Dataclasses (VulnerabilityExample, SimilarVuln, EnhancedFinding)
- SWC_REGISTRY (37 entries)
- EXPLOIT_EXAMPLES (23 entries)
- VulnerabilityRAG class methods

Author: Fernando Boiero <fboiero@frvm.utn.edu.ar>
Date: January 2026
"""

import pytest
import json
from unittest.mock import AsyncMock, MagicMock, patch
from dataclasses import asdict

from src.llm.vulnerability_rag import (
    VulnerabilityRAG,
    VulnerabilityExample,
    SimilarVuln,
    EnhancedFinding,
    SWC_REGISTRY,
    EXPLOIT_EXAMPLES,
)


# =============================================================================
# Fixtures
# =============================================================================


@pytest.fixture
def rag_instance():
    """Create a VulnerabilityRAG instance for testing."""
    return VulnerabilityRAG(
        ollama_base_url="http://localhost:11434",
        model="test-model",
        top_k=3,
    )


@pytest.fixture
def sample_reentrancy_finding():
    """Sample reentrancy finding for testing."""
    return {
        "type": "reentrancy",
        "severity": "high",
        "description": "Reentrancy vulnerability in withdraw function",
        "swc_id": "SWC-107",
        "location": {"file": "test.sol", "line": 10},
    }


@pytest.fixture
def sample_overflow_finding():
    """Sample overflow finding for testing."""
    return {
        "type": "integer-overflow",
        "severity": "high",
        "description": "Integer overflow possible in balance calculation",
        "swc_id": "SWC-101",
    }


@pytest.fixture
def sample_access_control_finding():
    """Sample access control finding for testing."""
    return {
        "type": "access-control",
        "severity": "critical",
        "description": "Missing access control on withdraw function",
        "swc_id": "SWC-105",
    }


@pytest.fixture
def vulnerable_code_reentrancy():
    """Sample vulnerable code with reentrancy."""
    return """
    function withdraw(uint256 amount) public {
        require(balances[msg.sender] >= amount);
        (bool success,) = msg.sender.call{value: amount}("");
        require(success);
        balances[msg.sender] -= amount;
    }
    """


@pytest.fixture
def vulnerable_code_overflow():
    """Sample vulnerable code with potential overflow."""
    return """
    function transfer(address to, uint256 amount) public {
        balances[msg.sender] -= amount;
        balances[to] += amount;
    }
    """


# =============================================================================
# Tests for Dataclasses
# =============================================================================


class TestVulnerabilityExample:
    """Tests for VulnerabilityExample dataclass."""

    def test_create_basic_example(self):
        """Test creating a basic VulnerabilityExample."""
        example = VulnerabilityExample(
            id="TEST-001",
            swc_id="SWC-107",
            cwe_id="CWE-841",
            title="Test Vulnerability",
            description="A test vulnerability description",
            vulnerable_code="function test() {}",
            fixed_code="function test() { check(); }",
            attack_scenario="Attack steps here",
            severity="high",
            category="reentrancy",
        )
        assert example.id == "TEST-001"
        assert example.swc_id == "SWC-107"
        assert example.cwe_id == "CWE-841"
        assert example.severity == "high"
        assert example.category == "reentrancy"

    def test_optional_fields_default(self):
        """Test that optional fields have correct defaults."""
        example = VulnerabilityExample(
            id="TEST-002",
            swc_id=None,
            cwe_id=None,
            title="Minimal Example",
            description="Minimal description",
            vulnerable_code="code",
            fixed_code=None,
            attack_scenario=None,
            severity="medium",
            category="test",
        )
        assert example.real_exploit is None
        assert example.tags == []
        assert example.embedding is None

    def test_example_with_tags(self):
        """Test VulnerabilityExample with tags."""
        tags = ["reentrancy", "external-call", "state-update"]
        example = VulnerabilityExample(
            id="TEST-003",
            swc_id="SWC-107",
            cwe_id="CWE-841",
            title="Tagged Example",
            description="Example with tags",
            vulnerable_code="code",
            fixed_code="fixed",
            attack_scenario="scenario",
            severity="high",
            category="reentrancy",
            tags=tags,
        )
        assert example.tags == tags
        assert len(example.tags) == 3

    def test_example_to_dict(self):
        """Test converting VulnerabilityExample to dict."""
        example = VulnerabilityExample(
            id="TEST-004",
            swc_id="SWC-101",
            cwe_id="CWE-190",
            title="Dict Test",
            description="Test description",
            vulnerable_code="code",
            fixed_code="fixed",
            attack_scenario="scenario",
            severity="high",
            category="arithmetic",
        )
        data = asdict(example)
        assert isinstance(data, dict)
        assert data["id"] == "TEST-004"
        assert data["swc_id"] == "SWC-101"


class TestSimilarVuln:
    """Tests for SimilarVuln dataclass."""

    def test_create_similar_vuln(self):
        """Test creating a SimilarVuln instance."""
        example = VulnerabilityExample(
            id="SWC-107",
            swc_id="SWC-107",
            cwe_id="CWE-841",
            title="Reentrancy",
            description="Reentrancy vulnerability",
            vulnerable_code="code",
            fixed_code="fixed",
            attack_scenario="scenario",
            severity="high",
            category="reentrancy",
        )
        similar = SimilarVuln(
            example=example,
            similarity_score=0.85,
            relevance_reason="Same vulnerability category",
        )
        assert similar.example == example
        assert similar.similarity_score == 0.85
        assert "category" in similar.relevance_reason

    def test_similarity_score_bounds(self):
        """Test similarity score can be any float."""
        example = VulnerabilityExample(
            id="TEST",
            swc_id=None,
            cwe_id=None,
            title="Test",
            description="Test",
            vulnerable_code="code",
            fixed_code=None,
            attack_scenario=None,
            severity="low",
            category="test",
        )
        # Score can be 0
        similar = SimilarVuln(example=example, similarity_score=0.0, relevance_reason="")
        assert similar.similarity_score == 0.0

        # Score can be 1
        similar = SimilarVuln(example=example, similarity_score=1.0, relevance_reason="")
        assert similar.similarity_score == 1.0


class TestEnhancedFinding:
    """Tests for EnhancedFinding dataclass."""

    def test_create_enhanced_finding(self):
        """Test creating an EnhancedFinding."""
        finding = {
            "type": "reentrancy",
            "severity": "high",
            "description": "Original description",
        }
        enhanced = EnhancedFinding(
            original_finding=finding,
            similar_vulns=[],
            enhanced_description="Enhanced description with more detail",
            exploit_scenario="Step 1: Deploy attack contract...",
            remediation_code="function withdraw() nonReentrant {}",
            confidence_adjustment=0.15,
            additional_references=["https://swcregistry.io/docs/SWC-107"],
        )
        assert enhanced.original_finding == finding
        assert enhanced.enhanced_description != finding["description"]
        assert enhanced.confidence_adjustment == 0.15
        assert len(enhanced.additional_references) == 1


# =============================================================================
# Tests for SWC_REGISTRY
# =============================================================================


class TestSWCRegistry:
    """Tests for SWC_REGISTRY completeness and validity."""

    def test_registry_has_expected_count(self):
        """Test that SWC_REGISTRY has the expected number of entries."""
        assert len(SWC_REGISTRY) >= 37, f"Expected at least 37 SWC entries, got {len(SWC_REGISTRY)}"

    def test_all_entries_are_vulnerability_examples(self):
        """Test that all registry entries are VulnerabilityExample instances."""
        for swc_id, example in SWC_REGISTRY.items():
            assert isinstance(example, VulnerabilityExample), f"{swc_id} is not a VulnerabilityExample"

    def test_swc_ids_match_keys(self):
        """Test that SWC IDs in examples match their dictionary keys."""
        for key, example in SWC_REGISTRY.items():
            if example.swc_id:
                assert example.swc_id == key, f"Key {key} doesn't match swc_id {example.swc_id}"

    def test_required_fields_are_present(self):
        """Test that all required fields are present in each entry."""
        required_fields = ["id", "title", "description", "vulnerable_code", "severity", "category"]
        for swc_id, example in SWC_REGISTRY.items():
            for field in required_fields:
                value = getattr(example, field)
                assert value is not None and value != "", f"{swc_id} missing {field}"

    def test_severity_values_are_valid(self):
        """Test that severity values are valid."""
        valid_severities = {"critical", "high", "medium", "low", "informational"}
        for swc_id, example in SWC_REGISTRY.items():
            assert example.severity.lower() in valid_severities, \
                f"{swc_id} has invalid severity: {example.severity}"

    def test_critical_swc_entries_exist(self):
        """Test that critical SWC entries exist."""
        critical_entries = [
            "SWC-107",  # Reentrancy
            "SWC-105",  # Unprotected Ether Withdrawal
            "SWC-106",  # Unprotected SELFDESTRUCT
            "SWC-101",  # Integer Overflow
            "SWC-104",  # Unchecked Call Return Value
            "SWC-112",  # Delegatecall to Untrusted Callee
            "SWC-115",  # tx.origin
            "SWC-116",  # Block timestamp
        ]
        for swc_id in critical_entries:
            assert swc_id in SWC_REGISTRY, f"Critical entry {swc_id} missing from registry"

    def test_new_v440_entries_exist(self):
        """Test that new v4.4.0 SWC entries exist."""
        v440_entries = [
            "SWC-100",  # Function Default Visibility
            "SWC-102",  # Outdated Compiler Version
            "SWC-103",  # Floating Pragma
            "SWC-108",  # State Variable Default Visibility
            "SWC-109",  # Uninitialized Storage Pointer
            "SWC-110",  # Assert Violation
            "SWC-119",  # Shadowing State Variables
            "SWC-120",  # Weak Sources of Randomness
            "SWC-124",  # Write to Arbitrary Storage
            "SWC-128",  # DoS With Block Gas Limit
        ]
        for swc_id in v440_entries:
            assert swc_id in SWC_REGISTRY, f"v4.4.0 entry {swc_id} missing from registry"

    def test_entries_have_tags(self):
        """Test that entries have meaningful tags."""
        for swc_id, example in SWC_REGISTRY.items():
            assert len(example.tags) > 0, f"{swc_id} has no tags"

    def test_vulnerable_code_is_not_empty(self):
        """Test that vulnerable_code examples are substantial."""
        for swc_id, example in SWC_REGISTRY.items():
            assert len(example.vulnerable_code.strip()) >= 10, \
                f"{swc_id} has too short vulnerable_code"


# =============================================================================
# Tests for EXPLOIT_EXAMPLES
# =============================================================================


class TestExploitExamples:
    """Tests for EXPLOIT_EXAMPLES completeness and validity."""

    def test_exploit_examples_count(self):
        """Test that EXPLOIT_EXAMPLES has expected count."""
        assert len(EXPLOIT_EXAMPLES) >= 20, f"Expected at least 20 exploits, got {len(EXPLOIT_EXAMPLES)}"

    def test_all_entries_are_vulnerability_examples(self):
        """Test that all exploit entries are VulnerabilityExample instances."""
        for exploit_id, example in EXPLOIT_EXAMPLES.items():
            assert isinstance(example, VulnerabilityExample), f"{exploit_id} is not a VulnerabilityExample"

    def test_exploits_have_real_exploit_field(self):
        """Test that exploits have the real_exploit field populated."""
        for exploit_id, example in EXPLOIT_EXAMPLES.items():
            assert example.real_exploit is not None, f"{exploit_id} missing real_exploit field"

    def test_recent_exploits_exist(self):
        """Test that recent 2023-2025 exploits exist."""
        recent_exploits = [
            "euler-finance-2023",
            "curve-vyper-reentrancy-2023",
            "sentiment-readonly-reentrancy-2023",
            "socket-bungee-2024",
            "lifi-2024",
            "penpie-2024",
        ]
        for exploit_id in recent_exploits:
            assert exploit_id in EXPLOIT_EXAMPLES, f"Recent exploit {exploit_id} missing"

    def test_exploits_have_attack_scenario(self):
        """Test that exploits have attack scenarios."""
        for exploit_id, example in EXPLOIT_EXAMPLES.items():
            assert example.attack_scenario is not None and len(example.attack_scenario) > 20, \
                f"{exploit_id} missing or too short attack_scenario"

    def test_exploit_categories_are_valid(self):
        """Test that exploit categories are meaningful."""
        valid_categories = {
            "flash-loan", "reentrancy", "oracle-manipulation", "price-manipulation",
            "read-only-reentrancy", "arbitrary-call", "precision-loss", "governance",
            "vyper-reentrancy", "cross-function-reentrancy", "access-control",
            "signature-replay", "storage-collision",
        }
        for exploit_id, example in EXPLOIT_EXAMPLES.items():
            # Category should exist
            assert example.category is not None and len(example.category) > 0, \
                f"{exploit_id} missing category"


# =============================================================================
# Tests for VulnerabilityRAG Class
# =============================================================================


class TestVulnerabilityRAGInit:
    """Tests for VulnerabilityRAG initialization."""

    def test_default_initialization(self):
        """Test default initialization."""
        rag = VulnerabilityRAG()
        assert rag.base_url == "http://localhost:11434"
        assert rag.model == "deepseek-coder:6.7b"
        assert rag.top_k == 3

    def test_custom_initialization(self):
        """Test custom initialization."""
        rag = VulnerabilityRAG(
            ollama_base_url="http://custom:1234",
            model="custom-model",
            top_k=5,
        )
        assert rag.base_url == "http://custom:1234"
        assert rag.model == "custom-model"
        assert rag.top_k == 5

    def test_knowledge_base_is_combined(self, rag_instance):
        """Test that knowledge base combines SWC and exploits."""
        total_expected = len(SWC_REGISTRY) + len(EXPLOIT_EXAMPLES)
        assert len(rag_instance.knowledge_base) == total_expected

    def test_tag_index_is_built(self, rag_instance):
        """Test that tag index is built on init."""
        assert len(rag_instance._tag_index) > 0
        # Common tags should be present
        assert "reentrancy" in rag_instance._tag_index or "reentrant" in rag_instance._tag_index


class TestVulnerabilityRAGTagIndex:
    """Tests for tag indexing functionality."""

    def test_tag_index_contains_categories(self, rag_instance):
        """Test that tag index includes categories."""
        # Check some expected categories are indexed
        categories_found = 0
        for category in ["reentrancy", "access-control", "arithmetic", "flash-loan"]:
            if category in rag_instance._tag_index:
                categories_found += 1
        assert categories_found >= 2, "Too few categories found in tag index"

    def test_tag_index_maps_to_valid_examples(self, rag_instance):
        """Test that tag index maps to valid example IDs."""
        for tag, example_ids in rag_instance._tag_index.items():
            for example_id in example_ids:
                assert example_id in rag_instance.knowledge_base, \
                    f"Tag '{tag}' maps to invalid example ID '{example_id}'"


class TestVulnerabilityRAGSearchSimilar:
    """Tests for search_similar method."""

    def test_search_by_swc_id(self, rag_instance, sample_reentrancy_finding):
        """Test searching by SWC ID."""
        results = rag_instance.search_similar(sample_reentrancy_finding)
        assert len(results) > 0
        # Should find SWC-107 as highly relevant
        swc_ids = [r.example.swc_id for r in results if r.example.swc_id]
        assert "SWC-107" in swc_ids

    def test_search_by_type(self, rag_instance):
        """Test searching by vulnerability type."""
        finding = {"type": "reentrancy", "description": "Reentrancy found"}
        results = rag_instance.search_similar(finding)
        assert len(results) > 0
        # All results should be reentrancy-related
        for result in results:
            assert "reentrancy" in result.example.category.lower() or \
                   "reentrancy" in result.example.title.lower() or \
                   "reentrant" in " ".join(result.example.tags).lower()

    def test_search_with_code_context(self, rag_instance, sample_reentrancy_finding, vulnerable_code_reentrancy):
        """Test search with code context improves results."""
        results_without_code = rag_instance.search_similar(sample_reentrancy_finding)
        results_with_code = rag_instance.search_similar(sample_reentrancy_finding, vulnerable_code_reentrancy)

        # Both should return results
        assert len(results_without_code) > 0
        assert len(results_with_code) > 0

        # Code similarity should affect scores (though not necessarily always higher)
        # Just verify it doesn't break
        assert all(0 <= r.similarity_score <= 1 for r in results_with_code)

    def test_search_returns_limited_results(self, rag_instance):
        """Test that search respects top_k limit."""
        finding = {"type": "reentrancy", "description": "Multiple matches expected"}
        rag_instance.top_k = 2
        results = rag_instance.search_similar(finding)
        assert len(results) <= 2

    def test_search_empty_finding(self, rag_instance):
        """Test searching with empty finding."""
        finding = {}
        results = rag_instance.search_similar(finding)
        # Should return empty or minimal results
        assert isinstance(results, list)

    def test_search_unknown_type(self, rag_instance):
        """Test searching with unknown vulnerability type."""
        finding = {"type": "unknown-type-xyz", "description": "Unknown"}
        results = rag_instance.search_similar(finding)
        # Should not crash, may return empty
        assert isinstance(results, list)

    def test_similarity_scores_are_normalized(self, rag_instance, sample_reentrancy_finding):
        """Test that similarity scores are between 0 and 1."""
        results = rag_instance.search_similar(sample_reentrancy_finding)
        for result in results:
            assert 0 <= result.similarity_score <= 1, \
                f"Score {result.similarity_score} out of bounds"

    def test_results_are_sorted_by_score(self, rag_instance, sample_reentrancy_finding):
        """Test that results are sorted by similarity score descending."""
        results = rag_instance.search_similar(sample_reentrancy_finding)
        if len(results) > 1:
            scores = [r.similarity_score for r in results]
            assert scores == sorted(scores, reverse=True), "Results not sorted by score"


class TestVulnerabilityRAGExtractKeywords:
    """Tests for _extract_keywords method."""

    def test_extract_common_keywords(self, rag_instance):
        """Test extracting common vulnerability keywords."""
        text = "Reentrancy vulnerability found in withdraw function"
        keywords = rag_instance._extract_keywords(text)
        assert "reentrancy" in keywords or "withdraw" in keywords

    def test_extract_multiple_keywords(self, rag_instance):
        """Test extracting multiple keywords."""
        text = "Oracle price manipulation via flash loan attack"
        keywords = rag_instance._extract_keywords(text)
        assert len(keywords) > 0
        # Should find multiple relevant keywords
        matches = sum(1 for k in keywords if k in ["oracle", "price", "flash", "loan"])
        assert matches >= 1

    def test_extract_limits_to_five(self, rag_instance):
        """Test that extraction is limited to 5 keywords."""
        text = "reentrancy overflow underflow delegatecall selfdestruct oracle flash loan price random"
        keywords = rag_instance._extract_keywords(text)
        assert len(keywords) <= 5

    def test_extract_case_insensitive(self, rag_instance):
        """Test that extraction is case insensitive."""
        text = "REENTRANCY OVERFLOW"
        keywords = rag_instance._extract_keywords(text)
        # Should still find keywords despite uppercase
        assert len(keywords) > 0


class TestVulnerabilityRAGCodeSimilarity:
    """Tests for _code_similarity method."""

    def test_identical_code_similarity(self, rag_instance):
        """Test that identical code has high similarity."""
        code = "function withdraw() { msg.sender.call{value: amount}(''); }"
        similarity = rag_instance._code_similarity(code, code)
        assert similarity == 1.0

    def test_different_code_similarity(self, rag_instance):
        """Test that different code has lower similarity."""
        code1 = "function withdraw() { msg.sender.call{value: amount}(''); }"
        code2 = "function deposit() { balances[msg.sender] += msg.value; }"
        similarity = rag_instance._code_similarity(code1, code2)
        assert 0 <= similarity < 1

    def test_empty_code_similarity(self, rag_instance):
        """Test similarity with empty code."""
        similarity = rag_instance._code_similarity("", "function test() {}")
        assert similarity == 0.0

    def test_similar_code_patterns(self, rag_instance):
        """Test that similar patterns have reasonable similarity."""
        code1 = """
        function withdraw(uint amount) public {
            require(balances[msg.sender] >= amount);
            msg.sender.call{value: amount}("");
            balances[msg.sender] -= amount;
        }
        """
        code2 = """
        function withdraw(uint256 _amount) external {
            require(balances[msg.sender] >= _amount);
            (bool success,) = msg.sender.call{value: _amount}("");
            require(success);
            balances[msg.sender] -= _amount;
        }
        """
        similarity = rag_instance._code_similarity(code1, code2)
        # Should have some similarity due to common patterns
        assert similarity > 0.3


class TestVulnerabilityRAGRelevanceReason:
    """Tests for _get_relevance_reason method."""

    def test_relevance_includes_category(self, rag_instance):
        """Test that relevance reason includes category match."""
        finding = {"type": "reentrancy"}
        example = VulnerabilityExample(
            id="TEST",
            swc_id="SWC-107",
            cwe_id="CWE-841",
            title="Reentrancy",
            description="Test",
            vulnerable_code="code",
            fixed_code="fixed",
            attack_scenario="scenario",
            severity="high",
            category="reentrancy",
            real_exploit="The DAO Hack",
        )
        reason = rag_instance._get_relevance_reason(finding, example)
        assert "category" in reason.lower() or "DAO" in reason

    def test_relevance_includes_exploit(self, rag_instance):
        """Test that relevance reason includes real exploit."""
        finding = {"type": "test"}
        example = VulnerabilityExample(
            id="TEST",
            swc_id=None,
            cwe_id=None,
            title="Test",
            description="Test",
            vulnerable_code="code",
            fixed_code=None,
            attack_scenario=None,
            severity="high",
            category="test",
            real_exploit="Famous Hack $100M",
        )
        reason = rag_instance._get_relevance_reason(finding, example)
        assert "exploit" in reason.lower() or "Famous Hack" in reason

    def test_relevance_includes_swc(self, rag_instance):
        """Test that relevance reason includes SWC reference."""
        finding = {"type": "test"}
        example = VulnerabilityExample(
            id="TEST",
            swc_id="SWC-107",
            cwe_id=None,
            title="Test",
            description="Test",
            vulnerable_code="code",
            fixed_code=None,
            attack_scenario=None,
            severity="high",
            category="other",
        )
        reason = rag_instance._get_relevance_reason(finding, example)
        assert "SWC" in reason


class TestVulnerabilityRAGParseJSON:
    """Tests for _parse_json method."""

    def test_parse_valid_json(self, rag_instance):
        """Test parsing valid JSON."""
        content = '{"key": "value", "number": 42}'
        result = rag_instance._parse_json(content)
        assert result == {"key": "value", "number": 42}

    def test_parse_json_with_surrounding_text(self, rag_instance):
        """Test parsing JSON embedded in text."""
        content = 'Here is the response: {"description": "Test", "severity": "high"} End of response.'
        result = rag_instance._parse_json(content)
        assert result["description"] == "Test"
        assert result["severity"] == "high"

    def test_parse_invalid_json(self, rag_instance):
        """Test parsing invalid JSON returns empty dict."""
        content = "This is not JSON at all"
        result = rag_instance._parse_json(content)
        assert result == {}

    def test_parse_malformed_json(self, rag_instance):
        """Test parsing malformed JSON returns empty dict."""
        content = '{"key": "value", incomplete'
        result = rag_instance._parse_json(content)
        assert result == {}

    def test_parse_empty_string(self, rag_instance):
        """Test parsing empty string."""
        result = rag_instance._parse_json("")
        assert result == {}


class TestVulnerabilityRAGGetSWCInfo:
    """Tests for get_swc_info method."""

    def test_get_existing_swc(self, rag_instance):
        """Test getting existing SWC info."""
        info = rag_instance.get_swc_info("SWC-107")
        assert info is not None
        assert info.swc_id == "SWC-107"
        assert "Reentrancy" in info.title

    def test_get_swc_case_insensitive(self, rag_instance):
        """Test that SWC lookup is case insensitive."""
        info_upper = rag_instance.get_swc_info("SWC-107")
        info_lower = rag_instance.get_swc_info("swc-107")
        # Both should return the same entry
        assert info_upper is not None
        assert info_lower is not None

    def test_get_nonexistent_swc(self, rag_instance):
        """Test getting nonexistent SWC returns None."""
        info = rag_instance.get_swc_info("SWC-999")
        assert info is None


class TestVulnerabilityRAGGetAllCategories:
    """Tests for get_all_categories method."""

    def test_get_categories_returns_list(self, rag_instance):
        """Test that get_all_categories returns a list."""
        categories = rag_instance.get_all_categories()
        assert isinstance(categories, list)

    def test_categories_are_sorted(self, rag_instance):
        """Test that categories are sorted."""
        categories = rag_instance.get_all_categories()
        assert categories == sorted(categories)

    def test_categories_include_expected(self, rag_instance):
        """Test that categories include expected values."""
        categories = rag_instance.get_all_categories()
        # Should have multiple categories
        assert len(categories) >= 5
        # Common categories should exist
        expected = ["reentrancy", "access-control", "arithmetic"]
        for cat in expected:
            assert cat in categories, f"Expected category '{cat}' not found"


# =============================================================================
# Tests for Async Methods (with mocking)
# =============================================================================


class TestVulnerabilityRAGAnalyzeWithContext:
    """Tests for analyze_with_context async method."""

    def test_analyze_with_context_structure(self, rag_instance, sample_reentrancy_finding):
        """Test analyze_with_context returns proper structure."""
        import asyncio
        code = "function withdraw() { msg.sender.call{value: amount}(''); }"

        async def run_test():
            # Mock the LLM call
            with patch.object(rag_instance, '_enhance_with_llm', new_callable=AsyncMock) as mock_enhance:
                mock_enhance.return_value = {
                    "description": "Enhanced description",
                    "exploit_scenario": "Attack steps",
                    "remediation_code": "Fixed code",
                }

                result = await rag_instance.analyze_with_context(sample_reentrancy_finding, code)

                assert isinstance(result, EnhancedFinding)
                assert result.original_finding == sample_reentrancy_finding
                assert isinstance(result.similar_vulns, list)
                assert isinstance(result.confidence_adjustment, float)

        asyncio.run(run_test())

    def test_analyze_builds_references(self, rag_instance, sample_reentrancy_finding):
        """Test that analyze builds proper references."""
        import asyncio
        code = "function withdraw() {}"

        async def run_test():
            with patch.object(rag_instance, '_enhance_with_llm', new_callable=AsyncMock) as mock_enhance:
                mock_enhance.return_value = {}

                result = await rag_instance.analyze_with_context(sample_reentrancy_finding, code)

                # Should have references if similar vulns found
                if result.similar_vulns:
                    # References should include SWC URLs or exploit names
                    assert isinstance(result.additional_references, list)

        asyncio.run(run_test())

    def test_analyze_confidence_adjustment(self, rag_instance, sample_reentrancy_finding):
        """Test confidence adjustment calculation."""
        import asyncio
        code = "function withdraw() { msg.sender.call{value: amount}(''); }"

        async def run_test():
            with patch.object(rag_instance, '_enhance_with_llm', new_callable=AsyncMock) as mock_enhance:
                mock_enhance.return_value = {}

                result = await rag_instance.analyze_with_context(sample_reentrancy_finding, code)

                # Confidence adjustment should be bounded
                assert 0 <= result.confidence_adjustment <= 0.2

        asyncio.run(run_test())


class TestVulnerabilityRAGEnhanceWithLLM:
    """Tests for _enhance_with_llm async method."""

    def test_enhance_with_llm_success(self, rag_instance):
        """Test successful LLM enhancement."""
        import asyncio
        finding = {"type": "reentrancy", "severity": "high", "description": "Test"}
        code = "function test() {}"
        context = "Similar vulnerability: Reentrancy"

        async def run_test():
            with patch('aiohttp.ClientSession') as mock_session:
                mock_response = AsyncMock()
                mock_response.status = 200
                mock_response.json = AsyncMock(return_value={
                    "message": {
                        "content": '{"description": "Enhanced", "exploit_scenario": "Steps", "remediation_code": "Fixed"}'
                    }
                })

                mock_session.return_value.__aenter__.return_value.post.return_value.__aenter__.return_value = mock_response

                result = await rag_instance._enhance_with_llm(finding, code, context)

                assert isinstance(result, dict)

        asyncio.run(run_test())

    def test_enhance_with_llm_failure(self, rag_instance):
        """Test LLM enhancement failure returns empty dict."""
        import asyncio
        finding = {"type": "test", "severity": "low", "description": "Test"}
        code = "function test() {}"
        context = ""

        async def run_test():
            with patch('aiohttp.ClientSession') as mock_session:
                mock_session.return_value.__aenter__.return_value.post.side_effect = Exception("Connection error")

                result = await rag_instance._enhance_with_llm(finding, code, context)

                assert result == {}

        asyncio.run(run_test())


# =============================================================================
# Integration Tests
# =============================================================================


class TestVulnerabilityRAGIntegration:
    """Integration tests for VulnerabilityRAG."""

    def test_full_search_workflow(self, rag_instance):
        """Test complete search workflow."""
        # Create a realistic finding
        finding = {
            "type": "reentrancy",
            "severity": "high",
            "description": "Potential reentrancy in withdraw function. External call before state update.",
            "swc_id": "SWC-107",
            "location": {"file": "Vault.sol", "line": 45},
        }

        code = """
        function withdraw(uint256 amount) external {
            require(balances[msg.sender] >= amount, "Insufficient balance");
            (bool success,) = msg.sender.call{value: amount}("");
            require(success, "Transfer failed");
            balances[msg.sender] -= amount;
        }
        """

        # Search for similar vulnerabilities
        results = rag_instance.search_similar(finding, code)

        # Should find relevant results
        assert len(results) > 0

        # Top result should be reentrancy-related
        top_result = results[0]
        assert "reentrancy" in top_result.example.category.lower() or \
               "reentrancy" in top_result.example.title.lower()

        # Should have reasonable score
        assert top_result.similarity_score > 0.3

        # Should have relevance reason
        assert len(top_result.relevance_reason) > 0

    def test_search_different_vulnerability_types(self, rag_instance):
        """Test searching for different vulnerability types."""
        vuln_types = [
            ("reentrancy", "SWC-107"),
            ("integer-overflow", "SWC-101"),
            ("access-control", "SWC-105"),
            ("delegatecall", "SWC-112"),
        ]

        for vuln_type, expected_swc in vuln_types:
            finding = {"type": vuln_type, "description": f"Test {vuln_type}"}
            results = rag_instance.search_similar(finding)

            # Should find something for common vulnerability types
            assert len(results) >= 0, f"No results for {vuln_type}"

    def test_knowledge_base_consistency(self, rag_instance):
        """Test that knowledge base is consistent."""
        # All SWC entries should be accessible
        for swc_id in SWC_REGISTRY.keys():
            info = rag_instance.get_swc_info(swc_id)
            assert info is not None, f"SWC {swc_id} not accessible via get_swc_info"

        # Categories should match entries
        categories = rag_instance.get_all_categories()
        for category in categories:
            # At least one entry should have this category
            found = False
            for example in rag_instance.knowledge_base.values():
                if example.category == category:
                    found = True
                    break
            assert found, f"Category {category} has no matching entries"


# =============================================================================
# Parametrized Tests
# =============================================================================


@pytest.mark.parametrize("swc_id,expected_severity", [
    ("SWC-107", "high"),      # Reentrancy
    ("SWC-105", "critical"),  # Unprotected Ether Withdrawal
    ("SWC-106", "critical"),  # Unprotected SELFDESTRUCT
    ("SWC-101", "high"),      # Integer Overflow
    ("SWC-104", "medium"),    # Unchecked Call Return Value
    ("SWC-103", "low"),       # Floating Pragma (if present)
])
def test_swc_severity_mapping(rag_instance, swc_id, expected_severity):
    """Test that SWC entries have correct severity."""
    info = rag_instance.get_swc_info(swc_id)
    if info:
        assert info.severity.lower() == expected_severity.lower(), \
            f"{swc_id} expected severity {expected_severity}, got {info.severity}"


@pytest.mark.parametrize("search_term", [
    "reentrancy",
    "overflow",
    "access",
    "oracle",
    "flash",
    "delegatecall",
])
def test_keyword_extraction_includes_term(rag_instance, search_term):
    """Test that keyword extraction finds specific terms."""
    text = f"This is a {search_term} vulnerability in the contract"
    keywords = rag_instance._extract_keywords(text)
    assert search_term in keywords, f"'{search_term}' not found in extracted keywords"
