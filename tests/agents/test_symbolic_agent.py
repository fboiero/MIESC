"""
Tests for SymbolicAgent - Manticore Integration

Tests cover enhanced Manticore functionality including:
- Exploit PoC generation
- Workspace findings extraction
- Vulnerability detection
- Transaction sequence analysis
"""

import pytest
import subprocess
from unittest.mock import Mock, patch, MagicMock
from pathlib import Path
import tempfile
import shutil

from src.agents.symbolic_agent import SymbolicAgent


class TestSymbolicAgentManticoreIntegration:
    """Tests for Manticore exploit generation and workspace analysis"""

    @pytest.fixture
    def agent(self):
        """Create SymbolicAgent instance"""
        return SymbolicAgent()

    def test_agent_initialization(self, agent):
        """Should initialize correctly"""
        assert agent.agent_name == "SymbolicAgent"
        assert "exploit_generation" in agent.capabilities
        assert agent.status == "initialized"

    def test_get_context_types(self, agent):
        """Should return correct context types"""
        context_types = agent.get_context_types()

        assert "symbolic_findings" in context_types
        assert "mythril_results" in context_types
        assert "manticore_results" in context_types
        assert len(context_types) == 3


class TestManticoreExploitGeneration:
    """Tests for exploit contract generation"""

    @pytest.fixture
    def agent(self):
        return SymbolicAgent()

    def test_generate_reentrancy_exploit(self, agent):
        """Should generate valid reentrancy exploit contract"""
        exploit = agent._generate_reentrancy_exploit("VulnerableBank")

        # Check structure
        assert "SPDX-License-Identifier" in exploit
        assert "pragma solidity" in exploit
        assert "contract ReentrancyExploit" in exploit

        # Check key functionality
        assert "function attack()" in exploit
        assert "receive() external payable" in exploit
        assert "target.withdraw" in exploit

        # Check comments
        assert "FOR EDUCATIONAL AND AUDITING PURPOSES ONLY" in exploit
        assert "Generated by MIESC SymbolicAgent" in exploit

    def test_generate_overflow_exploit(self, agent):
        """Should generate integer overflow exploit contract"""
        exploit = agent._generate_overflow_exploit("VulnerableToken")

        assert "SPDX-License-Identifier" in exploit
        assert "contract IntegerOverflowExploit" in exploit
        assert "function triggerOverflow()" in exploit
        assert "function triggerUnderflow()" in exploit
        assert "type(uint256).max" in exploit

    def test_generate_exploit_router(self, agent):
        """Should route to correct exploit generator"""
        # Test reentrancy routing
        exploit_reentrancy = agent._generate_exploit(
            "test.sol",
            "reentrancy",
            "Reentrancy found"
        )
        assert "ReentrancyExploit" in exploit_reentrancy

        # Test overflow routing
        exploit_overflow = agent._generate_exploit(
            "test.sol",
            "integer_overflow",
            "Overflow detected"
        )
        assert "IntegerOverflowExploit" in exploit_overflow

        # Test unknown type
        exploit_unknown = agent._generate_exploit(
            "test.sol",
            "unknown_type",
            "Unknown vulnerability"
        )
        assert exploit_unknown == ""


class TestManticoreWorkspaceExtraction:
    """Tests for Manticore workspace findings extraction"""

    @pytest.fixture
    def agent(self):
        return SymbolicAgent()

    @pytest.fixture
    def mock_workspace(self, tmp_path):
        """Create mock Manticore workspace"""
        workspace = tmp_path / "mcore_test_contract_12345"
        workspace.mkdir()

        # Create global.findings file
        findings_file = workspace / "global.findings"
        findings_file.write_text("""# Manticore Findings
Possible reentrancy vulnerability at line 42
Unchecked external call at line 56
Integer overflow in transfer function
""")

        # Create some test state directories
        (workspace / "test_00000001").mkdir()
        (workspace / "test_00000002").mkdir()
        (workspace / "test_00000003").mkdir()

        return workspace

    def test_extract_workspace_findings_success(self, agent, mock_workspace, monkeypatch):
        """Should extract findings from workspace"""
        # Change to temp directory
        monkeypatch.chdir(mock_workspace.parent)

        findings = agent._extract_workspace_findings("test_contract.sol")

        # Should extract 3 findings (excluding comment line)
        assert len(findings) == 3
        assert findings[0]["type"] == "workspace_finding"
        assert findings[0]["severity"] == "Medium"
        assert findings[0]["source"] == "manticore_workspace"
        assert "reentrancy" in findings[0]["description"].lower()

    def test_extract_workspace_findings_no_workspace(self, agent, tmp_path, monkeypatch):
        """Should handle missing workspace gracefully"""
        monkeypatch.chdir(tmp_path)

        findings = agent._extract_workspace_findings("nonexistent.sol")

        assert findings == []

    def test_extract_workspace_findings_empty_file(self, agent, tmp_path, monkeypatch):
        """Should handle empty findings file"""
        workspace = tmp_path / "mcore_test_12345"
        workspace.mkdir()
        (workspace / "global.findings").write_text("")

        monkeypatch.chdir(tmp_path)

        findings = agent._extract_workspace_findings("test.sol")

        assert findings == []


class TestManticoreExecution:
    """Tests for _run_manticore method"""

    @pytest.fixture
    def agent(self):
        return SymbolicAgent()

    def test_run_manticore_success(self, agent):
        """Should parse Manticore output correctly"""
        with patch('subprocess.run') as mock_run:
            # Mock successful Manticore execution
            mock_run.return_value = Mock(
                returncode=0,
                stdout="""
Manticore 0.3.7
Explored 15 states
Explored 3 paths
Integer overflow detected in function transfer()
Reentrancy vulnerability in withdraw()
                """,
                stderr=""
            )

            with patch.object(agent, '_extract_workspace_findings', return_value=[]):
                result = agent._run_manticore("test.sol", max_depth=128, timeout=900)

            assert result["tool"] == "Manticore"
            assert result["states_explored"] == 15
            assert result["paths_explored"] == 3
            assert len(result["vulnerabilities"]) == 2

            # Check integer overflow vulnerability
            overflow_vuln = next(
                v for v in result["vulnerabilities"]
                if v["type"] == "integer_overflow"
            )
            assert overflow_vuln["severity"] == "High"
            assert overflow_vuln["swc_id"] == "SWC-101"
            assert overflow_vuln["exploitable"] is True

            # Check reentrancy vulnerability
            reentrancy_vuln = next(
                v for v in result["vulnerabilities"]
                if v["type"] == "reentrancy"
            )
            assert reentrancy_vuln["severity"] == "Critical"
            assert reentrancy_vuln["swc_id"] == "SWC-107"

    def test_run_manticore_exploit_generation(self, agent):
        """Should generate exploits for exploitable vulnerabilities"""
        with patch('subprocess.run') as mock_run:
            mock_run.return_value = Mock(
                returncode=0,
                stdout="Reentrancy vulnerability in withdraw()",
                stderr=""
            )

            with patch.object(agent, '_extract_workspace_findings', return_value=[]):
                result = agent._run_manticore("VulnerableBank.sol", 128, 900)

            # Should have generated exploit
            assert len(result["exploits"]) >= 1

            exploit = result["exploits"][0]
            assert exploit["vulnerability_type"] == "reentrancy"
            assert exploit["severity"] == "Critical"
            assert exploit["swc_id"] == "SWC-107"
            assert "contract ReentrancyExploit" in exploit["exploit_contract"]

    def test_run_manticore_timeout(self, agent):
        """Should handle timeout gracefully"""
        with patch('subprocess.run') as mock_run:
            mock_run.side_effect = subprocess.TimeoutExpired("manticore", 900)

            result = agent._run_manticore("test.sol", 128, 900)

            assert result["error"] == "timeout"
            assert result["vulnerabilities"] == []
            assert result["exploits"] == []

    def test_run_manticore_not_installed(self, agent):
        """Should handle missing Manticore installation"""
        with patch('subprocess.run') as mock_run:
            mock_run.side_effect = FileNotFoundError()

            result = agent._run_manticore("test.sol", 128, 900)

            assert result["error"] == "not_installed"
            assert result["vulnerabilities"] == []

    def test_run_manticore_command_construction(self, agent):
        """Should construct correct Manticore command"""
        with patch('subprocess.run') as mock_run:
            mock_run.return_value = Mock(
                returncode=0,
                stdout="",
                stderr=""
            )

            with patch.object(agent, '_extract_workspace_findings', return_value=[]):
                agent._run_manticore("test.sol", max_depth=64, timeout=600)

            # Verify command
            call_args = mock_run.call_args[0][0]
            assert call_args[0] == "manticore"
            assert call_args[1] == "test.sol"
            assert "--max-depth" in call_args
            assert "64" in call_args
            assert "--quick-mode" in call_args
            assert "--verbose-trace" in call_args


class TestAggregateFindings:
    """Tests for findings aggregation"""

    @pytest.fixture
    def agent(self):
        return SymbolicAgent()

    def test_aggregate_mythril_findings(self, agent):
        """Should aggregate Mythril findings correctly"""
        mythril_data = {
            "vulnerabilities": [
                {
                    "swc_id": "SWC-107",
                    "title": "Reentrancy",
                    "severity": "High",
                    "description": "Reentrancy found",
                    "location": {"file": "test.sol", "line": 42},
                    "transaction_sequence": "deposit -> withdraw"
                }
            ]
        }

        manticore_data = {"vulnerabilities": [], "exploits": []}

        unified = agent._aggregate_findings(mythril_data, manticore_data)

        assert len(unified) == 1
        assert unified[0]["source"] == "Mythril"
        assert unified[0]["swc_id"] == "SWC-107"
        assert unified[0]["owasp_category"] == "SC01-Reentrancy"
        assert unified[0]["confidence"] == "High"

    def test_aggregate_manticore_vulnerabilities(self, agent):
        """Should aggregate Manticore vulnerabilities"""
        mythril_data = {"vulnerabilities": []}

        manticore_data = {
            "vulnerabilities": [
                {
                    "type": "integer_overflow",
                    "severity": "High",
                    "description": "Overflow detected",
                    "swc_id": "SWC-101",
                    "exploitable": True
                }
            ],
            "exploits": []
        }

        unified = agent._aggregate_findings(mythril_data, manticore_data)

        assert len(unified) == 1
        assert unified[0]["source"] == "Manticore"
        assert unified[0]["type"] == "integer_overflow"
        assert unified[0]["exploitable"] is True

    def test_aggregate_manticore_exploits(self, agent):
        """Should aggregate Manticore exploits as separate findings"""
        mythril_data = {"vulnerabilities": []}

        manticore_data = {
            "vulnerabilities": [],
            "exploits": [
                {
                    "vulnerability_type": "reentrancy",
                    "severity": "Critical",
                    "swc_id": "SWC-107",
                    "exploit_contract": "contract ReentrancyExploit {}"
                }
            ]
        }

        unified = agent._aggregate_findings(mythril_data, manticore_data)

        assert len(unified) == 1
        assert unified[0]["source"] == "Manticore"
        assert unified[0]["type"] == "exploit_poc"
        assert unified[0]["exploitable"] is True
        assert "exploit_contract" in unified[0]
        assert unified[0]["owasp_category"] == "SC01-Reentrancy"


class TestSWCMapping:
    """Tests for SWC to OWASP mapping"""

    @pytest.fixture
    def agent(self):
        return SymbolicAgent()

    def test_map_known_swc_ids(self, agent):
        """Should map known SWC IDs correctly"""
        assert agent._map_swc_to_owasp("SWC-107") == "SC01-Reentrancy"
        assert agent._map_swc_to_owasp("SWC-101") == "SC03-Arithmetic"
        assert agent._map_swc_to_owasp("SWC-104") == "SC04-Unchecked-Calls"
        assert agent._map_swc_to_owasp("SWC-105") == "SC02-Access-Control"
        assert agent._map_swc_to_owasp("SWC-120") == "SC06-Bad-Randomness"

    def test_map_unknown_swc_id(self, agent):
        """Should handle unknown SWC IDs"""
        assert agent._map_swc_to_owasp("SWC-999") == "SC10-Unknown-Unknowns"
        assert agent._map_swc_to_owasp("INVALID") == "SC10-Unknown-Unknowns"


def _is_manticore_available() -> bool:
    """Check if Manticore is available for testing"""
    try:
        result = subprocess.run(
            ["manticore", "--version"],
            capture_output=True,
            timeout=5
        )
        return result.returncode == 0
    except:
        return False


class TestSymbolicAgentIntegration:
    """Integration tests (requires Manticore installed)"""

    @pytest.mark.skipif(
        not _is_manticore_available(),
        reason="Manticore not installed"
    )
    def test_real_manticore_analysis(self, tmp_path):
        """Test real Manticore analysis (if available)"""
        # Create a simple vulnerable contract
        contract = tmp_path / "reentrancy.sol"
        contract.write_text("""
pragma solidity ^0.8.0;

contract VulnerableBank {
    mapping(address => uint) public balances;

    function deposit() public payable {
        balances[msg.sender] += msg.value;
    }

    function withdraw(uint amount) public {
        require(balances[msg.sender] >= amount);
        (bool success,) = msg.sender.call{value: amount}("");
        require(success);
        balances[msg.sender] -= amount;
    }

    function getBalance() public view returns (uint) {
        return balances[msg.sender];
    }
}
        """)

        # Run SymbolicAgent
        agent = SymbolicAgent()

        # Use short timeout for test
        result = agent._run_manticore(
            str(contract),
            max_depth=32,  # Shallow depth for faster test
            timeout=120     # 2 minutes
        )

        # Verify structure (even if no vulnerabilities found)
        assert "tool" in result
        assert result["tool"] == "Manticore"
        assert "vulnerabilities" in result
        assert "exploits" in result
        assert "metadata" in result
        assert result["metadata"]["analysis_type"] == "symbolic_execution"
        assert result["metadata"]["exploit_generation"] == "enabled"


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
